<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/12/20/opensecapp_cc_ratelimit/"/>
      <url>/2023/12/20/opensecapp_cc_ratelimit/</url>
      
        <content type="html"><![CDATA[<h1 id="rate-limit限速CC"><a href="#rate-limit限速CC" class="headerlink" title="rate_limit限速CC"></a>rate_limit限速CC</h1><h2 id="rate-limit-rate-limit-cc"><a href="#rate-limit-rate-limit-cc" class="headerlink" title="&#x2F;rate_limit&#x2F;rate_limit.cc"></a>&#x2F;rate_limit&#x2F;rate_limit.cc</h2><h3 id="一些重要的功能模块"><a href="#一些重要的功能模块" class="headerlink" title="一些重要的功能模块"></a>一些重要的功能模块</h3><ol><li>PatternMatcherBase<br>PatternMatcher.h</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PatternMatcherBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">const</span> std::string &amp;value)</span> <span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatternMatcherWildcard</span> : <span class="keyword">public</span> PatternMatcherBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PatternMatcherWildcard</span>(<span class="type">const</span> std::string &amp;pattern);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">const</span> std::string &amp;value)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_pattern;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatternMatcherRegex</span> : <span class="keyword">public</span> PatternMatcherBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PatternMatcherRegex</span>(<span class="type">const</span> std::string &amp;pattern);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">const</span> std::string &amp;value)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_pattern;</span><br><span class="line">    <span class="type">bool</span> m_regexError;</span><br><span class="line">    Regex m_regex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PatternMatcher.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PatternMatcherWildcard::match</span><span class="params">(<span class="type">const</span> std::string &amp;value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use unix filename (glob) string pattern matcher.</span></span><br><span class="line">    <span class="comment">// The Unix fnmatch() function only returns 0 in case of a succesful match.</span></span><br><span class="line">    <span class="comment">// In case no-match it returns FNM_NOMATCH constant.</span></span><br><span class="line">    <span class="comment">// In case of error it returns other non-zero return values.</span></span><br><span class="line">    <span class="comment">// However, in our usage here error is considered a &quot;no-match&quot;.</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">fnmatch</span>(m_pattern.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>(), <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载功能限速规则-findRateLimitRule"><a href="#加载功能限速规则-findRateLimitRule" class="headerlink" title="加载功能限速规则 findRateLimitRule"></a>加载功能限速规则 findRateLimitRule</h4><p> rate_limit_ctx：存储限速规则  </p><p>加载配置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">auto</span> maybe_rate_limit_config = <span class="built_in">getConfiguration</span>&lt;RateLimitConfig&gt;(<span class="string">&quot;rulebase&quot;</span>, <span class="string">&quot;rateLimit&quot;</span>);  </span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;rate_limit_config = maybe_rate_limit_config.<span class="built_in">unpack</span>();</span><br><span class="line">mode = rate_limit_config.<span class="built_in">getRateLimitMode</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getConfiguration具体加载原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> TypeWrapper &amp;</span><br><span class="line">ConfigComponent::Impl::<span class="built_in">getConfiguration</span>(<span class="type">const</span> vector&lt;string&gt; &amp;paths) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> curr_configs = configuration_nodes.<span class="built_in">find</span>(<span class="built_in">TenantProfilePair</span>(<span class="built_in">getActiveTenant</span>(), <span class="built_in">getActiveProfile</span>()));</span><br><span class="line">  <span class="comment">//通过调用 getActiveTenant() 和 getActiveProfile() 获取当前租户和配置文件，并用这两个结果构造一个 TenantProfilePair 对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curr_configs != configuration_nodes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> requested_config = curr_configs-&gt;second.<span class="built_in">find</span>(paths);</span><br><span class="line">        <span class="keyword">if</span> (requested_config != curr_configs-&gt;second.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : requested_config-&gt;second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">checkContext</span>(value.first)) <span class="keyword">return</span> value.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 使用上一步构造的 TenantProfilePair 对象，在 configuration_nodes 这个容器中查找当前的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> global_config = configuration_nodes.<span class="built_in">find</span>(<span class="built_in">TenantProfilePair</span>(default_tenant_id, default_profile_id));</span><br><span class="line">    <span class="keyword">if</span> (global_config != configuration_nodes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> requested_config = global_config-&gt;second.<span class="built_in">find</span>(paths);</span><br><span class="line">        <span class="keyword">if</span> (requested_config != global_config-&gt;second.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : requested_config-&gt;second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">checkContext</span>(value.first)) <span class="keyword">return</span> value.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载规则后获取application URL对URL进行剔除过滤</p><p>从rate_limit_config中获取限速规则.   getRateLimitRules() 见rate_limit_config.h</p><p>将过滤后的URI和规则进行拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string full_rule_uri = application_uri + rule.<span class="built_in">getRateLimitUri</span>();</span><br></pre></td></tr></table></figure><p>之后对url进行长度等校验，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (full_rule_uri_length &lt; rate_limit_longest_match) &#123;</span><br><span class="line">                   <span class="built_in">dbgDebug</span>(D_RATE_LIMIT)</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;rule is shorter then already matched rule. current rule length: &quot;</span></span><br><span class="line">                       &lt;&lt; full_rule_uri_length</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;, previously longest matched rule length: &quot;</span></span><br><span class="line">                       &lt;&lt; rate_limit_longest_match;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (full_rule_uri == matched_uri ||</span><br><span class="line">                   full_rule_uri == matched_uri + <span class="string">&quot;/&quot;</span> ||</span><br><span class="line">                   full_rule_uri + <span class="string">&quot;/&quot;</span> == matched_uri) &#123;</span><br><span class="line">                   <span class="built_in">dbgDebug</span>(D_RATE_LIMIT)</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;Found Exact match to request uri: &quot;</span></span><br><span class="line">                       &lt;&lt; matched_uri</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;, rule uri: &quot;</span></span><br><span class="line">                       &lt;&lt; full_rule_uri;</span><br><span class="line">                   <span class="keyword">return</span> rule;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>最终返回限速规则。</p><h4 id="执行规则-respond"><a href="#执行规则-respond" class="headerlink" title="执行规则 respond"></a>执行规则 respond</h4><p>身份校验</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> maybe_source_identifier = env-&gt;<span class="built_in">get</span>&lt;string&gt;(HttpTransactionData::source_identifier);</span><br><span class="line"><span class="keyword">if</span> (!maybe_source_identifier.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="built_in">dbgWarning</span>(D_RATE_LIMIT) &lt;&lt; <span class="string">&quot;Unable to get source identifier from context, not enforcing rate limit&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ACCEPT;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>IP校验</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> maybe_source_ip = env-&gt;<span class="built_in">get</span>&lt;IPAddr&gt;(HttpTransactionData::client_ip_ctx);</span><br><span class="line">        string source_ip = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (maybe_source_ip.<span class="built_in">ok</span>()) source_ip = <span class="built_in">ipAddrToStr</span>(maybe_source_ip.<span class="built_in">unpack</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldApplyException</span>(uri, source_identifier, source_ip)) &#123;</span><br><span class="line">            <span class="built_in">dbgDebug</span>(D_RATE_LIMIT) &lt;&lt; <span class="string">&quot;found accept exception, not enforcing rate limit on this uri: &quot;</span> &lt;&lt; uri;</span><br><span class="line">            <span class="keyword">return</span> ACCEPT;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>拼接asset_id，source_identifier，uri为unique_key，根据unique来decide并匹配限速策略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">RateLimitVedit</span> &#123; ACCEPT, DROP, DROP_AND_LOG &#125;;</span><br></pre></td></tr></table></figure><p>当mode为Active时候执行DROP策略（mode 为private部分）</p><h4 id="RateLimitVedit策略判断-decide"><a href="#RateLimitVedit策略判断-decide" class="headerlink" title="RateLimitVedit策略判断 decide"></a>RateLimitVedit策略判断 decide</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RateLimitVedict</span></span><br><span class="line"><span class="function">    <span class="title">decide</span><span class="params">(<span class="type">const</span> string &amp;key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redis == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dbgDebug</span>(D_RATE_LIMIT)</span><br><span class="line">                &lt;&lt; <span class="string">&quot;there is no connection to the redis at the moment, unable to enforce rate limit&quot;</span>;</span><br><span class="line">            <span class="built_in">reconnectRedis</span>();</span><br><span class="line">            <span class="keyword">return</span> RateLimitVedict::ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisReply* reply = <span class="built_in">static_cast</span>&lt;redisReply*&gt;(<span class="built_in">redisCommand</span>(redis, <span class="string">&quot;EVALSHA %s 1 %s %f %d&quot;</span>,</span><br><span class="line">        rate_limit_lua_script_hash.<span class="built_in">c_str</span>(), key.<span class="built_in">c_str</span>(), limit, burst));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reply == <span class="literal">NULL</span> || redis-&gt;err) &#123;</span><br><span class="line">            <span class="built_in">dbgDebug</span>(D_RATE_LIMIT)</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Error executing Redis command: No reply received, unable to enforce rate limit&quot;</span>;</span><br><span class="line">            <span class="built_in">reconnectRedis</span>();</span><br><span class="line">            <span class="keyword">return</span> RateLimitVedict::ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redis&#x27;s lua script returned true - accept</span></span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">            <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">            <span class="keyword">return</span> RateLimitVedict::ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redis&#x27;s lua script returned false - drop, no need to log</span></span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">            <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">            <span class="keyword">return</span> RateLimitVedict::DROP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redis&#x27;s lua script returned string - drop and send log</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* log_str = <span class="string">&quot;BLOCK AND LOG&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STRING &amp;&amp; <span class="built_in">strncmp</span>(reply-&gt;str, log_str, <span class="built_in">strlen</span>(log_str)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">            <span class="keyword">return</span> RateLimitVedict::DROP_AND_LOG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dbgDebug</span>(D_RATE_LIMIT)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Got unexected reply from redis. reply type: &quot;</span></span><br><span class="line">            &lt;&lt; reply-&gt;type</span><br><span class="line">            &lt;&lt; <span class="string">&quot;. not enforcing rate limit for this request.&quot;</span>;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> RateLimitVedict::ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rate-limit-rate-limit-config-cc"><a href="#rate-limit-rate-limit-config-cc" class="headerlink" title="&#x2F;rate_limit&#x2F;rate_limit_config.cc"></a>&#x2F;rate_limit&#x2F;rate_limit_config.cc</h2><p>主要是通过cereal对请求的速率配置进行序列化和加载逻辑的实现</p><h2 id="include-rate-limit-h"><a href="#include-rate-limit-h" class="headerlink" title="&#x2F;include&#x2F;rate_limit.h"></a>&#x2F;include&#x2F;rate_limit.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RATE_LIMIT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RATE_LIMIT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;component.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i_mainloop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i_environment.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i_generic_rulebase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimit</span></span><br><span class="line">    :</span><br><span class="line">    <span class="keyword">public</span> Component,</span><br><span class="line">    Singleton::Consume&lt;I_MainLoop&gt;,</span><br><span class="line">    Singleton::Consume&lt;I_TimeGet&gt;,</span><br><span class="line">    Singleton::Consume&lt;I_Environment&gt;,</span><br><span class="line">    Singleton::Consume&lt;I_GenericRulebase&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RateLimit</span>();</span><br><span class="line">    ~<span class="built_in">RateLimit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preload</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fini</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __RATE_LIMIT_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="include-rate-limit-config-h"><a href="#include-rate-limit-config-h" class="headerlink" title="&#x2F;include&#x2F;rate_limit_config.h"></a>&#x2F;include&#x2F;rate_limit_config.h</h2><p>rule规则校验</p><h2 id="RaterLimiter-cc"><a href="#RaterLimiter-cc" class="headerlink" title="RaterLimiter.cc"></a>RaterLimiter.cc</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>作用是提供一个速率限制器，来控制事件发生的频率。主要通过循环数组来实现一个固定时间窗口内的事件计数，确保事件的频率不会超过允许的最大值。</p><h3 id="速率限制器event方法"><a href="#速率限制器event方法" class="headerlink" title="速率限制器event方法"></a>速率限制器event方法</h3><p>这个方法在后面的监测判断中使用，用于记录一个新事件，并根据规则确定事件是否可以被接受，完整代码见：components&#x2F;security_apps&#x2F;waap&#x2F;waap_clib&#x2F;RateLimiter.cc</p><ul><li><p>空速率限制处理：也就是速率限制器被初始化为0秒间隔（没有限制），那么所有的事件都被接受（<code>m_hitsPerSecond</code> &#x3D; 0)</p></li><li><p>重置速率限制器状态：首次记录事件或长时间无事件发生后重新开始一段新的监视周期时，清除当前的事件计数。这通过 <code>clear(now)</code> 方法重置 <code>m_hitsPerSecond</code>、<code>m_recentIdx</code>、<code>m_recentHitTime</code> 和 <code>m_hitsCount</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// Clear counts buffer on the very first event, of after whole interval passed without events</span></span><br><span class="line"><span class="keyword">if</span> (m_recentHitTime == std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>) || now - m_recentHitTime &gt;= m_interval) &#123;</span><br><span class="line">    <span class="built_in">clear</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新计数器和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m_recentHitTime &lt; now) &#123;</span><br><span class="line">        <span class="comment">// switch idx to next slot (with wrap since this is circular buffer).</span></span><br><span class="line">        <span class="comment">// since this is circular buffer, the next slot is actually a tail (oldest): wrap ---&gt;[HEAD][TAIL]---&gt; wrap</span></span><br><span class="line">        m_recentIdx++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_recentIdx &gt;= m_hitsPerSecond.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            m_recentIdx = <span class="number">0</span>; <span class="comment">//循环缓存区</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// forget the hits from the oldest second in this interval (deduct them from total count)</span></span><br><span class="line">        m_hitsCount -= m_hitsPerSecond[m_recentIdx]; <span class="comment">// 将最老的秒（即将被覆盖的时间槽）的事件数从总计数中减去。</span></span><br><span class="line">        m_hitsPerSecond[m_recentIdx] = <span class="number">0</span>; <span class="comment">// 清空该时间槽</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update recentHitTime (switch to next second)</span></span><br><span class="line">        m_recentHitTime += std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>最新的秒时间槽增加命中，同时总点击数<code>m_hitCount</code>增加</p></li><li><p>事件接受性判断：如果计数后的 <code>m_hitsCount</code> 仍然小于或等于 <code>m_max_events</code>（一段时间内允许的最大事件数），则表示事件可以被接受，返回 <code>true</code>；否则表示速率过高，返回 <code>false</code>。当在限制的时间内达到了阈值则新的事件不会被接受。</p></li></ul><h2 id="RaterLimit-h"><a href="#RaterLimit-h" class="headerlink" title="RaterLimit.h"></a>RaterLimit.h</h2><p>主要是一些初始化声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Waap &#123;</span><br><span class="line"><span class="keyword">namespace</span> Util &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple rate limiter primitive that collects events() and only allows up to X events per Y seconds.</span></span><br><span class="line"><span class="comment">// For each event, call RateLimiter::event() passing real or simulated timestamp (in seconds).</span></span><br><span class="line"><span class="comment">// The returned boolean value will tell the caller whether this event must pass (true) or be blocked (false).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RateLimiter</span>(<span class="type">unsigned</span> <span class="type">int</span> events, std::chrono::seconds interval);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">const</span> std::chrono::seconds&amp; now)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(<span class="type">const</span> std::chrono::seconds&amp; now)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> m_max_events; <span class="comment">// max events allowed during the recent interval window</span></span><br><span class="line">    std::chrono::seconds m_interval; <span class="comment">// configured interval window</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span>&gt; m_hitsPerSecond; <span class="comment">// array of hitcounts per second (remembers up to interval recent seconds)</span></span><br><span class="line">    <span class="type">unsigned</span> m_recentIdx;  <span class="comment">// index of recent second</span></span><br><span class="line">    std::chrono::seconds m_recentHitTime; <span class="comment">// timestamp of recent second</span></span><br><span class="line">    <span class="type">unsigned</span> m_hitsCount; <span class="comment">// total events during last interval seconds (rolling update)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RaterLimiting-cc"><a href="#RaterLimiting-cc" class="headerlink" title="RaterLimiting.cc"></a>RaterLimiting.cc</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>主功能速率限制实现点，防止滥用和恶意行为。基于复杂规则集对请求进行限制和跟踪，能够在达到过载条件时候为web应用提供保护，并且规则可以根据URL和源进行细化，为每个规则创建单独的速率限制器状态跟踪表，并采取相应的行动，如记录、临时阻止、完全阻止。</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>LRU策略 #define RATE_LIMITING_LRU_SIZE 10000</p><ul><li>为每个规则创建单独的速率限制器状态跟踪表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">State::<span class="built_in">State</span>(<span class="type">const</span> std::shared_ptr&lt;Policy&gt; &amp;policy)</span><br><span class="line">:<span class="built_in">policy</span>(policy), <span class="built_in">perRuleTrackingTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// For each rule create separate rate limiter states tracking table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> ruleId=<span class="number">0</span>; ruleId &lt; policy-&gt;rules.<span class="built_in">size</span>(); ++ruleId) &#123;</span><br><span class="line">        perRuleTrackingTable.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;EntriesLru&gt;(RATE_LIMITING_LRU_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重点还是在State的execute，对于速率限制跟踪表的设计</li></ul><h4 id="Lru-cache-map及速率限制跟踪表的设计"><a href="#Lru-cache-map及速率限制跟踪表的设计" class="headerlink" title="Lru_cache_map及速率限制跟踪表的设计"></a>Lru_cache_map及速率限制跟踪表的设计</h4><img src="https://cdn.jsdelivr.net/gh/Syruichi/blogImage@main/img/202401101546858.png" alt="image-20240110154622251" style="zoom:50%;" /><p>Lru_cache_map具体实现见<a href="https://sourcegraph.com/github.com/openappsec/openappsec@dfff43d4c1db637311e89fea84ea2e899ffb9790/-/blob/components/security_apps/waap/waap_clib/lru_cache_map.h?L22:7-22:18">components&#x2F;security_apps&#x2F;waap&#x2F;waap_clib&#x2F;lru_cache_map.h</a></p><h4 id="execute实现"><a href="#execute实现" class="headerlink" title="execute实现"></a>execute实现</h4><ul><li><p>设置初始变量，allow &#x3D; true,log &#x3D; true</p></li><li><p>遍历policy策略对象里定义的所有规则</p></li><li><p>获取速率限制跟踪表以及根据规则的groupBy设置来构建entryKey对象来作为在LRU表中查找条目的键</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get rate limiter states tracking table specific to current rule</span></span><br><span class="line"> std::shared_ptr&lt;EntriesLru&gt; table = perRuleTrackingTable[ruleId];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build a key to look up an entry</span></span><br><span class="line"> EntryKey entryKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uriFilter.groupBy == Policy::Rule::UriFilter::GroupBy::URL) &#123;</span><br><span class="line">            <span class="comment">// Include the HTTP source ID in the key</span></span><br><span class="line">            entryKey.url = uriStr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sourceFilter.groupBy == Policy::Rule::SourceFilter::GroupBy::SOURCE) &#123;</span><br><span class="line">    <span class="comment">// Include the HTTP source ID in the key</span></span><br><span class="line">    entryKey.source = sourceIdentifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来是筛选的过程，检查<code>请求的 URI</code> 和<code>源标识符</code>是否符合当前规则的过滤条件。如果设置的范围是 <code>SPECIFIC</code>并且匹配检查没有通过，则跳过当前规则的其他步骤。</p></li><li><p>在LRU表中根据entryKey查找对应的trackEntry对象，以及执行创建，插入，更新等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;TrackEntry&gt; trackEntry;</span><br><span class="line"><span class="keyword">if</span> (!table-&gt;<span class="built_in">get</span>(entryKey, trackEntry)) &#123;</span><br><span class="line">    trackEntry = std::<span class="built_in">make_shared</span>&lt;TrackEntry&gt;(rate.events,     std::chrono::<span class="built_in">seconds</span>(rate.interval));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert or update an entry in LRU (this moves entry up if exist, or inserts new, possibly expiring old ones</span></span><br><span class="line"><span class="comment">// to keep the LRU size under control).</span></span><br><span class="line">table-&gt;<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(entryKey, trackEntry));</span><br></pre></td></tr></table></figure></li><li><p>在trackEntry速率限制器上调用event方法来记录新event并执行对应的操作，如果返回值为false则表示速率已满</p><ul><li><p>event方法：计数此事件，如果速率限制器未饱和（应该允许），则结果将为 true，如果速率限制器饱和，则结果将为 false &#x2F;&#x2F; 是（应该阻止）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">TrackEntry::event</span><span class="params">(std::chrono::seconds now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Release temporary block when time arrives</span></span><br><span class="line">    <span class="keyword">if</span> (state == TrackEntry::State::QUARANTINED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= quarantinedUntil) &#123;</span><br><span class="line">            <span class="comment">// Release blocking state</span></span><br><span class="line">            state = TrackEntry::State::MEASURING;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count this event, the result will be true if rate limiter not saturated (should allow), or false if it</span></span><br><span class="line">    <span class="comment">// is (should block).</span></span><br><span class="line">    <span class="keyword">return</span> eventRateLimiter.<span class="built_in">event</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<a href="https://sourcegraph.com/github.com/openappsec/openappsec@dfff43d4c1db637311e89fea84ea2e899ffb9790/-/blob/components/security_apps/waap/waap_clib/RateLimiter.h?L25:7-25:18">components&#x2F;security_apps&#x2F;waap&#x2F;waap_clib&#x2F;RateLimiter.h</a>，<a href="https://sourcegraph.com/github.com/openappsec/openappsec@dfff43d4c1db637311e89fea84ea2e899ffb9790/-/blob/components/security_apps/waap/waap_clib/RateLimiter.cc?L19:1-19:12">components&#x2F;security_apps&#x2F;waap&#x2F;waap_clib&#x2F;RateLimiter.cc</a>中实现了速率限制器，具体见RaterLimiter.cc中的说明</p></li></ul></li><li><p>达到速率限制，请求过多，则根据规则的Action进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count this event in the entry&#x27;s rate limiter. Release temporary block if time arrived.</span></span><br><span class="line">  <span class="keyword">if</span> (trackEntry-&gt;<span class="built_in">event</span>(now) == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// TrackEntry&#x27;s rate limiter is saturated (too many requests) - act according to rule&#x27;s Action</span></span><br><span class="line">      <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">          <span class="keyword">case</span> Policy::Rule::Action::Type::DETECT:</span><br><span class="line">              <span class="comment">// log block action.</span></span><br><span class="line">              log = <span class="literal">true</span>;</span><br><span class="line">              <span class="comment">// Detect</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Policy::Rule::Action::Type::QUARANTINE:</span><br><span class="line">              <span class="comment">// Mark this entry blocked temorarily, for at least X seconds</span></span><br><span class="line">              trackEntry-&gt;<span class="built_in">quarantineUntil</span>(now + std::chrono::<span class="built_in">seconds</span>(action.quarantineTimeSeconds));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Policy::Rule::Action::Type::RATE_LIMIT:</span><br><span class="line">              <span class="comment">// log block action.</span></span><br><span class="line">              log = <span class="literal">true</span>;</span><br><span class="line">              <span class="comment">// Block this event only</span></span><br><span class="line">              allow = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此前有对action的&#x3D;进行重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">Policy::Rule::Action::<span class="keyword">operator</span>==(<span class="type">const</span> Policy::Rule::Action &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quarantineTimeSeconds == other.quarantineTimeSeconds &amp;&amp;</span><br><span class="line">        type == other.type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有一条规则显示阻止则阻止该请求，如果 <code>trackEntry</code> 表示条目已被封禁或速率限制，则设置 <code>allow</code> 为 <code>false</code> 并记录日志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">TrackEntry::isBlocked</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state != TrackEntry::State::MEASURING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RaterLimiting-h"><a href="#RaterLimiting-h" class="headerlink" title="RaterLimiting.h"></a>RaterLimiting.h</h2><h3 id="Policy-类"><a href="#Policy-类" class="headerlink" title="Policy 类"></a>Policy 类</h3><p><code>Policy</code> 是一个配置容器，它包含了与速率限制执行相关的规则集合以及是否启用速率限制的状态。这个类和它的嵌套子类（<code>Rule</code>, <code>UriFilter</code>, <code>SourceFilter</code>, <code>Rate</code>, <code>Action</code>, <code>RateLimitingEnforcement</code>）都实现了 <code>serialize</code> 方法和 <code>operator==</code>（用于比较各自的实例）。</p><ul><li><p><code>struct Rule</code>：定义了单一规则，其中包含了 URI 过滤UriFilter、源过滤SourceFilter、速率限定Rate和动作定义Action。</p><ul><li><code>struct UriFilter</code>：定义了基于 URI 组的过滤逻辑，可以是全部 URI (<code>ALL</code>) 或 特定 URI (<code>SPECIFIC</code>)。</li><li><code>struct SourceFilter</code>：定义了源过滤逻辑，可以是全部来源 (<code>ALL</code>) 或特定来源 (<code>SPECIFIC</code>)。</li><li><code>struct Rate</code>：定义了事件的频率，包括时间间隔和时间间隔内允许的事件数。</li><li><code>struct Action</code>：定义了规则的行为，包括 <code>DETECT</code>、<code>QUARANTINE</code>、<code>RATE_LIMIT</code>。</li></ul></li><li><p><code>class RateLimitingEnforcement</code>：表示速率限制是否被应用，当level为prevent时enable &#x3D; true。</p></li></ul><h4 id="一些库的使用"><a href="#一些库的使用" class="headerlink" title="一些库的使用"></a>一些库的使用</h4><p>借用cereal库实现对std::vector和std::unordered_map等对象的序列化和反序列化，如</p><ol><li><strong><code>&lt;cereal/types/vector.hpp&gt;</code></strong>: 这是 cereal 序列化库的一部分，它提供了对 <code>std::vector</code> 容器的序列化和反序列化支持。使用这个库，你可以将 <code>std::vector</code> 对象保存到文件中并且在需要的时候读取回来。</li><li><strong><code>&lt;cereal/types/unordered_map.hpp&gt;</code></strong>: 同样是 cereal 序列化库的一部分，这个库提供了对 <code>std::unordered_map</code> 容器的序列化和反序列化支持。这使得 <code>std::unordered_map</code> 对象可以被序列化到各种格式，比如 JSON、XML 等。</li><li><strong><code>&lt;cereal/archives/json.hpp&gt;</code></strong>: 这个库也是 cereal 序列化库的一部分，它提供了一个JSON存档类用于序列化对象到 JSON 格式，或者从 JSON 格式反序列化。这使得与 JSON 数据的读写交互变得容易。</li></ol><p>具体可以在UriFilter中看到使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _A&gt; <span class="comment">// 范型类型_A</span></span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(_A &amp;ar)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">               std::string groupByStr; <span class="comment">// 存储序列化过程中groupBy的成员对象</span></span><br><span class="line">               <span class="built_in">ar</span>(cereal::<span class="built_in">make_nvp</span>(<span class="string">&quot;groupBy&quot;</span>, groupByStr));<span class="comment">// 创建一个键值对，允许保留变量的名称，同时在序列化过程中，这条语句会保存或恢复 groupByStr 的值，具体取决于 ar 是用于输出还是输入数据。</span></span><br><span class="line">               groupBy = <span class="built_in">strGroupByToEnum</span>(groupByStr); <span class="comment">// 利用自定义方法将字符串类型转为枚举类型</span></span><br><span class="line">               std::string scopeStr;</span><br><span class="line">               <span class="built_in">ar</span>(cereal::<span class="built_in">make_nvp</span>(<span class="string">&quot;scope&quot;</span>, scopeStr));</span><br><span class="line">               scope = <span class="built_in">strScopeToEnum</span>(scopeStr);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(scope == Scope::SPECIFIC) <span class="comment">//特定URI处理</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">ar</span>(cereal::<span class="built_in">make_nvp</span>(<span class="string">&quot;specific_uris&quot;</span>, specific_uri_regexes_pattern));</span><br><span class="line">                   specific_uri_regexes.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;specific_uri_pattern : specific_uri_regexes_pattern)</span><br><span class="line">                   &#123;</span><br><span class="line">                       specific_uri_regexes.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;boost::regex&gt;(specific_uri_pattern)); <span class="comment">// 为每个模式字符串创建一个新的boost::regex对象，并作为共享指针添加到specific_uri_regexes向量中</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对于boost算法库的使用：</p><ol><li><strong><code>&lt;boost/algorithm/string/predicate.hpp&gt;</code></strong>: 提供了关于字符串比较的功能，如判断一个字符串是否以另一个字符串开头（<code>boost::starts_with</code>）或结尾（<code>boost::ends_with</code>）。</li><li><strong><code>&lt;boost/algorithm/string/case_conv.hpp&gt;</code></strong>: 这个库提供了字符串大小写转换功能，比如把一个字符串全都转化为小写（<code>boost::to_lower_copy</code>）或大写（<code>boost::to_upper_copy</code>）。</li><li><strong><code>&lt;boost/regex.hpp&gt;</code></strong>: 提供比标准库中更丰富的正则表达式支持，包括对复杂正则表达式语法的支持，以及一些增强的匹配和搜索功能。在代码中，它用于创建和比较正则表达式对象，以匹配和过滤具体的 URI 和源。</li></ol><h3 id="EntryKey-结构体"><a href="#EntryKey-结构体" class="headerlink" title="EntryKey 结构体"></a>EntryKey 结构体</h3><p><code>EntryKey</code> 是一个空间键（Space Key），用于在速率限制中唯一地识别一个条目。它由请求的 <code>url</code> 和 <code>source</code> 组成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Key used to identify specific rate limiting entry</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EntryKey</span> &#123;</span><br><span class="line">    std::string url;</span><br><span class="line">    std::string source;</span><br><span class="line">    <span class="comment">// comparison operator should be implemented to use this struct as a key in an LRU cache.</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(EntryKey <span class="type">const</span>&amp; other) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TrackEntry-结构体"><a href="#TrackEntry-结构体" class="headerlink" title="TrackEntry 结构体"></a>TrackEntry 结构体</h3><p><code>TrackEntry</code> 表示一个被跟踪的条目。</p><p>它具有一个速率限制器 <code>eventRateLimiter</code> 用于限制事件发生的频率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waap::Util::RateLimiter eventRateLimiter;</span><br></pre></td></tr></table></figure><p>一个状态(<code>state</code>)表示当前条目是否被测量或隔离，enum</p><p><code>quarantinedUntil</code>，是一个时间点，表示隔离状态到此时间为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quarantineUntil</span><span class="params">(std::chrono::seconds until)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="State-类"><a href="#State-类" class="headerlink" title="State 类"></a>State 类</h3><p><code>State</code> 类保持每个资源的速率限制状态。它包含一个指向 <code>Policy</code> 对象的共享指针和一个追踪表 <code>perRuleTrackingTable</code>，用于为每个规则维护对应的跟踪状态（<code>EntriesLru</code>）实例。</p><p><code>execute</code>方法执行速率限制策略，评估请求是否符合Policy定义的每一个规则并相应地进行访问限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> LruCacheMap&lt;EntryKey, std::shared_ptr&lt;TrackEntry&gt;&gt; EntriesLru;</span><br><span class="line">        <span class="type">const</span> std::shared_ptr&lt;Policy&gt; policy;</span><br><span class="line">        <span class="comment">// For each rule - hold corresponding tracking state (EntriesLru) instance</span></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;EntriesLru&gt;&gt; perRuleTrackingTable;</span><br><span class="line">        <span class="built_in">State</span>(<span class="type">const</span> std::shared_ptr&lt;Policy&gt; &amp;policy);</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> std::string&amp; sourceIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> std::string&amp; uriStr,</span></span></span><br><span class="line"><span class="params"><span class="function">            std::chrono::seconds now,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">bool</span>&amp; log)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RaterLimitingDecision-cc"><a href="#RaterLimitingDecision-cc" class="headerlink" title="RaterLimitingDecision.cc"></a>RaterLimitingDecision.cc</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RateLimitingDecision.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">RateLimitingDecision::<span class="built_in">RateLimitingDecision</span>(DecisionType type) : <span class="built_in">SingleDecision</span>(type)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">RateLimitingDecision::getTypeStr</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Rate Limiting&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RaterLimitingDecision-h"><a href="#RaterLimitingDecision-h" class="headerlink" title="RaterLimitingDecision.h"></a>RaterLimitingDecision.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RATE_LIMITING_DECISION_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RATE_LIMITING_DECISION_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SingleDecision.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DecisionType.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimitingDecision</span>: <span class="keyword">public</span> SingleDecision</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RateLimitingDecision</span><span class="params">(DecisionType type)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getTypeStr</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
